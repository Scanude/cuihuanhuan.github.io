---
title: 《高性能 JavaScript》笔记
categories: 读书笔记
tags: 读书笔记
---

<h4>《高性能 JavaScript》笔记</h4>

网摘:

github:https://github.com/wy-ei/notebook/issues/34#issuecomment-266937340

**加载和执行**

javascript 是单线程的。且多数浏览器是使用单一进程来处理用户界面的刷新和javascript代码的执行的，所以 javascript 执行时间越久，页面等待时间就会越久。

在页面中每次出现 script 标签的时候，就意味着浏览器需要去执行这些代码，页面也就会处于暂停状况。为什么 javascript 的执行不能和页面的渲染并行呢，因为 javascript 的执行有时候决定了页面如何进行渲染。因为脚本可能在执行的过程中向页面中添加内容。

比如使用 

```
document.write
```

使用 src 属性加载外部 javascript 文件的时候也是如此，浏览器必须等待文件加载完毕，并执行该文件，执行完毕后再继续解析 HTML 代码。在这个阶段用户的交互和页面渲染是完全被阻塞的。

**脚本位置**：

浏览器在解析到 body 之前是不会开始渲染页面的，所以将大量的脚本或者样式表放在 head 部分会导致页面长时间处于空白。

file1.js —> load —> exec —> file2.js —> load —> exec —> file3.js —> load —> exec

ok，虽然浏览器支持并行下载，但是执行上一定是串行的，所以尽可能将脚本放在最接近 body 底部的地方。

**将内嵌脚本放在 head 中的情况**

为了确保脚本执行时候得到的是正确的样式，所以这会阻塞页面等到样式表的加载完毕。

**脚本数量**

考虑到 http 连接的开销，可以将小的脚本文件进行压缩。

**无阻塞的脚本**

javascript 倾向于阻塞用户界面和 HTTP 请求。减小 javascript 文件的大小，并减少http请求数量只是第一步。

**延迟脚本**

defer ，async 属性

作用：异步加载脚本，不阻塞页面的渲染。保证脚本不会修改 DOM
区别：async 是 HTML5 标准中提出的，在脚本加载完毕后立刻执行，defer 是早 HTML4 中提出的，是在 dom 加载完成后执行。

目前所有主流浏览器都实现了以上属性的支持，有一点需要注意的是 defer 只作用于使用 src 加载的脚本

**动态脚本**

AMD:require.js
CMD:sea.js
**解决方法**

压缩代码
合并脚本
lazyload
**DOM 编程**

使用脚本对 DOM 进行操作的代价很昂贵。

**天生就慢**

因为 DOM 是独立于语言的，它提供了操作文档的 API，它和 ECMAScript 是分开的，它们两者就像是使用一座桥梁链接起来的一样，每当需要跨越这座桥梁的时候就要收取一些费用，所以要尽量减少过桥的次数。

- 减少DOM的访问，把事情尽量留在 javascript 这边进行

- 缓存DOM集合的长度，因为DOM集合是动态的，每次访问其中的属性都要进行一次查询。

**元素集合**

使用 firstElementChild 等只获得元素节点的方法，而不是使用 firstChild 并判断其 nodeType 是否为 3

**选择器API**

querySelectorAll 返回一个 NodeList 其中保存了所有符合选择器的元素的引用，这个集合不是动态的，不对随着文档的改变而改变。

**重绘与重排**

浏览器在下载完成所有的资源之后，会建立两个内部的数据结构：

DOM：表示页面结构
渲染：表示DOM节点如何显示
每当DOM元素的宽高，颜色等改变，都会触发渲染树的更新，对于尺寸变化会进行一次重新排版，然后在重新绘制。并不是任何操作都会触发重排，比如背景色的变化就只会触发一次重绘，因为布局并没有改变。

**重排何时发生**

添加或者删除可见元素
元素位置改变
元素尺寸改变
内容改变
页面渲染初始化
浏览器尺寸变化
**渲染树变化的排队和刷新**

由于每次重排都会产生计算消耗，所以浏览器会通过队列来批量执行重排过程。然而在读取元素的 offset_。scroll_，client* 等属性的时候，由于要获取到当前准确的信息，这个时候会强制进行重排以返回正确值。

**最小化重绘与重排**

- 批量改变样式


使用 el.style.cssText 来批量添加，或者在后面追加。

- 批量修改 DOM


当需要对 DOM 进行一系列操作的时候，可以采用下面的方式：

- 隐藏DOM



- 对其应用多次修改


- 重新显示该元素

其他一些方案：使用文档片段

- 缓存布局信息


因为在每次获取布局信息的时候都要进行渲染树的刷新，所以可以缓存下布局信息，避免频繁获取这些信息。

- 让元素脱离动画流


有的时候页面的顶部有一个动画，这个元素的高度不断变大，然后将下面的内容撑到下面，这个时候会导致整个页面的重绘，使得整个页面看起来一顿一顿的。解决方法是将这个元素在动画开始前设置为 绝对定位，让其脱离文档流，然后在应用动画，这个时候就只会对这个元素以及这个元素遮挡的元素进行重绘，在动画结束后再恢复定位让他回到标准流中。

- IE:hover


对于元素很多的时候，不要对大量元素使用 hover 选择器。在 IE8 中性能很差。

- 事件委托


利用事件冒泡的机制来处理大量的事件的绑定。

##### GPU 是如何加速网页渲染的

前端工程师应该都听说过硬件加速，通常它是指利用 GPU 来加速页面的渲染。那么 GPU 目前在web页面的渲染过程中起到什么作用呢？

GPU 的作用

早期浏览器完全依赖 CPU 来进行页面渲染。现在随着 GPU 的能力增强和普及，且目前绝大多数运行浏览器的设备上都集成了 GPU。浏览器可以利用 GPU 来加速网页渲染。

GPU 包含几百上千个核心，但每个核心的结构都相对简单， GPU 的结构也决定了它适合用来进行大规模并行计算。进行图层合并需要操作大量的像素，这方面 GPU 能比 CPU 更高效的完成。这里有个视频(http://v.youku.com/v_show/id_XNjY3MTY4NjAw.html)，很清楚地说明 CPU 与 GPU 的差别。

页面渲染过程

浏览器利用 HTML 构建出 DOM 树，利用 CSS 构建 CSSOM 树，最终得到 Render 树。

![img](/img/js-css/js-demo-1.jpg)

然而这只是很宏观的描述，浏览器为了将 DOM 元素高效地绘制且正确地出来，将多个元素安排在一个图层中，使用 PaintLayer 来描述，在每个 PaintLayer 中又存在 GraphicsLayers。当某个元素的样式改变后，不需要去重绘某个图层就好了。

浏览器的每一帧都可能会经过以下几个步骤：

![img](/img/js-css/js-demo-2.jpg)

JavaScript 的执行可能修改 DOM 树和 CSSOM 树，随后浏览器需要重新计算样式，并根据新的样式计算出元素的实际属性（比如 CSS 中 width 是 50%，这里就要利用父元素的宽度得出自己真实的 width 值），重绘有变动的图层，随后将各图层传递给 GPU ，由 GPU 来进行图层的合并。

上面 5 个步骤中，Layout 和 Paint 是可以省略的，当修改后的样式不会改变元素的尺寸、位置等涉及布局的属性时候，就没有必要进行 Layout（计算布局），比如修改了 color 属性，这个时候就只需要进行重绘（Paint）步骤。同样的道理，修改某些属性也不需要进行 Paint 步骤，只需要 Composite 就可以。

因此，我们希望所做的操作能尽可能地避免 Layout 和 Paint 这两个步骤，这样一帧所需的时间也就会大大缩短，可以明显避免卡顿。

目前有三个属性的改变只需要进行 Composite 过程，分别是：

filter
transform
opacity
这几个属性的改变，GPU 只需要在合并图层之前对图层进行一些变换，比如 opacity 属性的改变，GPU 只需要在合并之前改变图层的 alpha 通道。transform 和 filter 的改变 GPU 也可以利用矩阵变换很快地得到变化后的图层。

正确地利用 GPU

使用 transform, filter 和 opacity 来完成动画

使用以上 3 个属性来完成动画，可以避免在动画的每一帧进行重绘。如果在动画中改变了其他属性，那也不能避免重新绘制。

避免不合理地强制开启硬件加速

常常看到有文章指出使用 transform:translateZ(0); 这样的 hark 可以强制开启硬件加速来提高性能，这是错误的说法，要知道所谓的硬件加速就是利用 GPU 来将本就存在于 GPU 中的图层进行一些变换得到新的图层。如果改变的属性必须要要进行重绘，比如改变了 background 属性，那么图层还是要进行重绘然后重新加载至 GPU 中。这个时候就算强制开启硬件加速也没有什么用。

使用 transform:translateZ(0); 这样的 CSS hark 写法会将元素提升至单独的图层。在这么做之前要考虑为什么要这样做，创建新的图层的目的应该是，避免某个元素的改变导致大面积重绘，比如某个小标签的颜色的改变，导致大面积重绘，因此将其提升至单独的图层中。这里有个例子，小标签背景色的改变会导致大面积的重绘，但是如果将其提升至单独的图层后，改变它的背景色将只会重绘它自身。你可以代码 Chrome 调试工具，通过 Timeline 观察每次闪烁重绘的内容。

而如果整个图层的都要被重绘，那么再将其中的部分元素提升至单独的图层，会导致重绘的时候会分多个图层来进行绘制，然后在进行多个图层的合并，这个时候不如将所有元素放置在单个图层中，重绘整个大的图层。

总结

所谓硬件加速，早起浏览器是使用纯软件来渲染页面的，如今现代浏览器利用了 GPU 来进行页面的渲染，在合适的时候浏览器就会自动去使用 GPU 而不是开发者自己去指定。GPU 的功能是在合并图层阶段，它可以在进行图层合并之前来对原图层进行一些变换，合理地使用这个变换可以避免页面重绘，使得每一帧消耗的时间最少，避免卡顿。




